- 기능 요구 사항

- 사용자는 상품 목록의 상품을 장바구니에 추가할 수 있다.
- 상품을 클릭하면 상품 상세로 이동한다.
    - 상품을 상세하게 볼 수 있다

- 장바구니
- 상품 상세에서 장바구니에 상품을 담을 수 있다.
- 장바구니에서 원하는 상품을 삭제할 수 있다.

상품 목록에서 장바구니 화면으로 이동할 수 있다

상품 상세 화면에서 장바구니 담기를 눌렀을 때 사용자에게 상품이 담겼음을 알려준다

# 낙서장 

## MVP에서 MVVM으로..

### MVP + DataBinding 사용하기

이전에는 MVP 디자인 아키텍처 패턴과 DataBinding을 사용했었다.

MVP 구조에서는 Presenter가 Model을 통해 UI Model을 변경하고, 이를 다시 View에 바인딩하는 방식으로 동작한다. 
이 과정에서 View와 Presenter 사이에 강한 결합이 형성되며, Presenter는 View에 대한 참조를 보유하고, View의 특정 메서드를 호출하여 UI를 업데이트한다. 
이러한 접근 방식은 유지보수가 어렵고, UI가 자주 변경되는 상황에서 코드가 복잡해질 수 있다. 다른 곳에서는 테스트 코드 작성도 어렵다고 하는데 개인적으로 테스트 코드를 작성할 때,어렵다고 생각하지는 않았다. 
또한, 데이터 관리도 어렵다. 예를 들어, 화면 회전과 같은 상황에서는 데이터를 저장하고 복원하는 작업이 필요하다. 
더불어 MVP에서는 데이터 바인딩의 강력한 기능을 활용할 수 없었기 때문에 DataBinding 대신 ViewBinding을 사용하는 것이 적합하다고 생각했다.

이러한 단점을 극복하기 위해 그것들이 등장했다.


### LivaData와 ViewModel에 등장..!

이러한 번거러움을 없애기 위해 나온 것이 LivaData + ViewModel이다.

위에서 말한 번거러움을 LiveData + ViewModel로 해결한 문제점은 다음과 같다.

1. View와 Presenter 간의 강한 결합이 되어 있음
    - ViewModel은 View에 직접적으로 의존하지 않으며, 데이터 바인딩을 통해 View에 반영된다.
    - 이는 View와 ViewModel 간의 결합도를 낮추어 테스트와 유지보수를 용이하게 한다.
2. 데이터 관리가 어려움
    - ViewModel의 생명주기는 Activity나 Fragment와 다르게 관리된다.
    - LifecycleOwner가 생성되고 완전히 사라질 때까지 지속된다.
    - 이로써 ViewModel에서 데이터를 관리하면 화면 회전 등의 상황에서도 이전 데이터로 화면을 쉽게 초기화할 수 있다.
3. 데이터 바인딩의 강력한 기능 활용 부재
    - LiveData를 사용하여 UI의 상태를 구독하고, 데이터 바인딩을 통해 데이터를 관찰한다.
    - UI의 상태가 변할 때마다 LiveData가 자동으로 UI를 업데이트한다.
    - 즉, 데이터 바인딩을 통해 View와 ViewModel 간의 동기화를 자동으로 처리한다.

이러한 개선 사항으로 MVP의 한계를 극복하고자 하던 과정에서 LiveData의 옵저버 패턴과 ViewModel의 등장으로 인해 MVVM 패턴이 자연스럽게 등장한 것으로 보인다.

LiveData는 2017년 5월에 발표되었으며, ViewModel은 2017년 10월에 발표되었다고 한다.
아마도 MVP에 

### MVVM 디자인 아키텍처 패턴의 동작 방식

MVVM 패턴의 동작 방식은 다음과 같이 일어난다.

1. View와 ViewModel은 데이터 바인딩을 통해 연결된다. View에서 특정 UI 요소는 ViewModel의 속성에 바인딩되어 있으며, ViewModel의 데이터 변경 시 자동으로 UI가 업데이트된다.
2. ViewModel은 Model과 상호 작용하여 필요한 데이터를 가져온다. 이러한 작업은 주로 비즈니스 로직의 수행 및 데이터 소스에 대한 요청을 포함힌다.
3. 사용자의 상호 작용은 View에서 발생하며, 이를 ViewModel이 처리한다. 사용자 입력을 ViewModel이 받아들이고 필요한 작업을 수행한 후, 필요한 경우 Model과 상호 작용하여 데이터를 업데이트하거나 새로운 데이터를 가져올 수 있다.
4. ViewModel은 Model의 변경 사항을 관찰하고, 변경 시 View에 알리는 역할을 한다. 이는 주로 LiveData 또는 Observable 패턴을 통해 구현된다. 데이터가 변경되면 ViewModel이 이를 감지하고 UI에 적절한 업데이트를 요청한다.

### 한마디로 MVVM은?
즉, MVVM에서 Model, View, ViewModel은 다음과 같은 역할을 수행한다.

Model: 애플리케이션의 데이터와 비즈니스 로직을 처리
View: 사용자 인터페이스 요소를 담당, XML 등과 같은 선언적 언어를 통해 정의되며, ViewModel에 바인딩된다.
ViewModel: View와 Model 간의 중재자 역할을 한다. ViewModel은 View에 필요한 데이터를 제공하고, 사용자 입력을 받아 Model을 업데이트하고 데이터 바인딩을 통해 View와 자동으로 동기화된다.

